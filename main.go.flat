package main

import (
	"encoding/csv"
	"fmt"
	"log"
	"os"
	"runtime"
	"strconv"
	"time"

	"github.com/shirou/gopsutil/v3/cpu"
	"github.com/shirou/gopsutil/v3/mem"
	"github.com/shirou/gopsutil/v3/process"
)

// processInfo holds the name and start time for a tracked process.
type processInfo struct {
	Name      string
	StartTime time.Time
}

// dataRecord holds all the information we want to save for an event.
type dataRecord struct {
	Timestamp            string
	PID                  int32
	ProcessName          string
	Status               string    // "Started", "Exited", "Active", "Heartbeat"
	Duration             string    // Total runtime, only for "Exited" status
	CPUPercent           float64   // For "Started" and "Active" status
	MemoryPercent        float32   // For "Started" and "Active" status
	OverallSystemCPU     float64   // Overall system CPU usage
	PerCoreSystemCPU     []float64 // Per-core system CPU usage
	TotalSystemMemUsedGB float64
}

const (
	logInterval = 1 * time.Millisecond // How often to collect data
	csvFilename = "system_log.csv"     // The name of the output file
)

// activeProcesses tracks all running processes that we've seen, mapping PID to its info.
var activeProcesses = make(map[int32]processInfo)

func main() {
	log.Println("Starting system monitor...")
	log.Printf("Data will be collected every %v and saved to %s", logInterval, csvFilename)
	log.Printf("Detected %d CPU cores.", runtime.NumCPU())

	initializeCSV()
	populateInitialProcesses()

	ticker := time.NewTicker(logInterval)
	defer ticker.Stop()

	// Run once immediately, then wait for the ticker.
	collectAndLogData()

	for {
		select {
		case <-ticker.C:
			collectAndLogData()
		}
	}
}

// initializeCSV creates the CSV file and writes the dynamic header row.
func initializeCSV() {
	_, err := os.Stat(csvFilename)
	if !os.IsNotExist(err) {
		log.Printf("Found existing CSV file: %s. Appending new data.", csvFilename)
		return
	}

	log.Printf("CSV file not found. Creating %s with headers.", csvFilename)
	file, err := os.Create(csvFilename)
	if err != nil {
		log.Fatalf("Failed to create CSV file: %v", err)
	}
	defer file.Close()

	writer := csv.NewWriter(file)
	defer writer.Flush()

	// Build Dynamic Headers
	headers := []string{
		"Timestamp",
		"PID",
		"ProcessName",
		"Status",
		"Duration",
		"ProcessCPUPercent",
		"ProcessMemoryPercent",
		"OverallSystemCPUUsagePercent",
	}

	numCPU := runtime.NumCPU()
	for i := 0; i < numCPU; i++ {
		headers = append(headers, fmt.Sprintf("Core%d_Percent", i))
	}
	headers = append(headers, "TotalSystemMemoryUsedGB")

	if err := writer.Write(headers); err != nil {
		log.Fatalf("Failed to write headers to CSV: %v", err)
	}
}

// populateInitialProcesses gets the initial list of running processes.
func populateInitialProcesses() {
	processes, err := process.Processes()
	if err != nil {
		log.Printf("Warning: Could not get initial process list: %v", err)
		return
	}
	scriptStartTime := time.Now()
	for _, p := range processes {
		name, err := p.Exe() // Changed from p.Name()
		if err != nil {
			name = "N/A"
		}
		activeProcesses[p.Pid] = processInfo{
			Name:      name,
			StartTime: scriptStartTime, // Assume they started when the script did
		}
	}
	log.Printf("Initial scan complete. Tracking %d running processes.", len(activeProcesses))
}

// collectAndLogData gathers stats, detects process changes, and logs data for all active processes.
func collectAndLogData() {
	log.Println("Collecting data...")
	var records []dataRecord
	currentTime := time.Now()

	// --- 1. Get Total System Stats ---
	overallPercentages, _ := cpu.Percent(time.Millisecond, false)
	perCorePercentages, _ := cpu.Percent(time.Millisecond, true)
	vm, _ := mem.VirtualMemory()
	overallCPUUsage := overallPercentages[0]
	totalMemUsedGB := float64(vm.Used) / (1024 * 1024 * 1024)

	// --- 2. Check for Process Changes and Log Data ---
	allProcs, err := process.Processes()
	if err != nil {
		log.Printf("Error getting process list: %v", err)
		return
	}

	currentPIDs := make(map[int32]*process.Process)
	for _, p := range allProcs {
		currentPIDs[p.Pid] = p
	}

	// Check for EXITED processes
	for pid, info := range activeProcesses {
		if _, exists := currentPIDs[pid]; !exists {
			duration := currentTime.Sub(info.StartTime).Round(time.Millisecond).String()
			records = append(records, dataRecord{
				Timestamp:   currentTime.Format(time.RFC3339),
				PID:         pid,
				ProcessName: info.Name,
				Status:      "Exited",
				Duration:    duration,
			})
			delete(activeProcesses, pid) // Remove from our tracking map
		}
	}

	// Log ACTIVE processes and check for NEW processes
	for pid, p := range currentPIDs {
		cpuP, _ := p.CPUPercent()
		memP, _ := p.MemoryPercent()

		if info, exists := activeProcesses[pid]; exists {
			// It's an ACTIVE, already tracked process. Log its current state.
			records = append(records, dataRecord{
				Timestamp:            currentTime.Format(time.RFC3339),
				PID:                  pid,
				ProcessName:          info.Name, // Use the stored name for consistency
				Status:               "Active",
				CPUPercent:           cpuP,
				MemoryPercent:        memP,
				OverallSystemCPU:     overallCPUUsage,
				PerCoreSystemCPU:     perCorePercentages,
				TotalSystemMemUsedGB: totalMemUsedGB,
			})
		} else {
			// It's a NEW process. Log it as "Started".
			name, _ := p.Exe() // Changed from p.Name()
			records = append(records, dataRecord{
				Timestamp:            currentTime.Format(time.RFC3339),
				PID:                  pid,
				ProcessName:          name,
				Status:               "Started",
				CPUPercent:           cpuP,
				MemoryPercent:        memP,
				OverallSystemCPU:     overallCPUUsage,
				PerCoreSystemCPU:     perCorePercentages,
				TotalSystemMemUsedGB: totalMemUsedGB,
			})
			// Add to our tracking map
			activeProcesses[pid] = processInfo{Name: name, StartTime: currentTime}
		}
	}

	// --- 3. Write to CSV ---
	if len(records) > 0 {
		if err := appendToCSV(records); err != nil {
			log.Printf("Error writing to CSV: %v", err)
		}
		log.Printf("Successfully logged %d records (active, started, exited).", len(records))
	} else {
		log.Println("No running processes found. Logging heartbeat.")
		// Log a "heartbeat" if there are no processes to log at all
		heartbeatRecord := []dataRecord{{
			Timestamp:            currentTime.Format(time.RFC3339),
			ProcessName:          "SYSTEM_HEARTBEAT",
			Status:               "Heartbeat",
			OverallSystemCPU:     overallCPUUsage,
			PerCoreSystemCPU:     perCorePercentages,
			TotalSystemMemUsedGB: totalMemUsedGB,
		}}
		if err := appendToCSV(heartbeatRecord); err != nil {
			log.Printf("Error writing heartbeat to CSV: %v", err)
		}
	}
}

// appendToCSV appends records to the CSV file.
func appendToCSV(data []dataRecord) error {
	file, err := os.OpenFile(csvFilename, os.O_WRONLY|os.O_CREATE|os.O_APPEND, 0644)
	if err != nil {
		return fmt.Errorf("failed to open CSV file: %w", err)
	}
	defer file.Close()

	writer := csv.NewWriter(file)
	defer writer.Flush()

	for _, record := range data {
		// Start with the base columns
		row := []string{
			record.Timestamp,
			strconv.Itoa(int(record.PID)),
			record.ProcessName,
			record.Status,
			record.Duration,
			strconv.FormatFloat(record.CPUPercent, 'f', 2, 64),
			strconv.FormatFloat(float64(record.MemoryPercent), 'f', 2, 32),
			strconv.FormatFloat(record.OverallSystemCPU, 'f', 2, 64),
		}

		// Append the per-core CPU data
		numCores := runtime.NumCPU()
		if len(record.PerCoreSystemCPU) > 0 {
			for _, corePercent := range record.PerCoreSystemCPU {
				row = append(row, strconv.FormatFloat(corePercent, 'f', 2, 64))
			}
		} else {
			// Add empty placeholders if there's no per-core data (e.g., for "Exited" events)
			for i := 0; i < numCores; i++ {
				row = append(row, "")
			}
		}

		// Append the final memory column
		row = append(row, strconv.FormatFloat(record.TotalSystemMemUsedGB, 'f', 2, 64))

		if err := writer.Write(row); err != nil {
			log.Printf("Failed to write record %+v to CSV: %v", record, err)
		}
	}
	return writer.Error()
}
